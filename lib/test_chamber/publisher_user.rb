module TestChamber
  # A publisher user represents a unique user within an individual app in the
  # Tapjoy platform.  Identifying users at this level is primarily (read: only)
  # used for currency tracking purposes.  In this case, a user is basically a
  # consumer (in the case of games, you would call it the player).
  # 
  # Publisher users are constructed of two components:
  # 1. The id of the application they belong to
  # 2. The id of the user within that application.  This id can be specified by
  #    the publisher or it can be generated by Tapjoy based on one or more
  #    identifiers provided by the device (install id, udid, etc.)
  class PublisherUser
    include TestChamber::Rest

    def self.base_url
      @base_url ||= URI("#{TestChamber.target_url}/").tap {|uri| uri.port = 3001}.to_s
    end

    # The application the publisher user belongs to
    attr_reader :app

    # The device providing additional information (if necessary) to help
    # generate a unique user id
    attr_reader :device

    # The unique identifier for the user within the application
    attr_reader :user_id

    def initialize(options = {})
      raise "App is a required parameter" if options[:app].blank?

      @app = options[:app]
      @device = options[:device]
      @user_id = options[:user_id] || device && device.publisher_user_id
      @params = {:app_id => app.id, :publisher_user_id => user_id}

      # If a device is provided, then additional identifiers are provided in
      # order to generate the user_id
      if device
        @params.merge!(
          :udid => device.udid,
          :advertising_id => device.advertising_id,
          :mac_address => device.mac_address,
          :android_id => device.android_id,
          :install_id => device.install_id
        )
      end
    end

    # Awards the given number of points to the user.  Note that the change will
    # *not* be immediately reflected in the balance since it can occur in the
    # background.
    def award_points(points, options = {})
      params = @params.merge(
        :guid => SecureRandom.uuid,
        :timestamp => Time.now.to_f,
        :tap_points => points
      ).merge(options)
      params[:verifier] = generate_verifier(params, [params[:tap_points], params[:guid]])

      response = rest_request(:get, "#{self.class.base_url}points/award?#{params.to_query}", format: :xml)
      check_response(response)
      true
    end

    # Debits the given number of points from the user's balance.  Similar to
    # +award_points+, you should not assume that the balance will be instantly
    # updated when this completes.
    def spend_points(points)
      params = @params.merge(:tap_points => points)
      params[:verifier] = generate_verifier(params)

      response = rest_request(:get, "#{self.class.base_url}points/spend?#{params.to_query}", format: :xml)
      check_response(response)
      true
    end

    # The virtual currency balance for the user
    def point_balance
      params = @params

      response = rest_request(:get, "#{self.class.base_url}get_vg_store_items/user_account?#{params.to_query}", format: :xml)
      check_response(response)
      Hash.from_xml(response[:body])['TapjoyConnectReturnObject']['UserAccountObject']['TapPoints'].to_i
    end

    private
    # The current VCS APIs do not always return 4xx / 5xx response codes when a
    # failure has occurred.  Instead, it reutrns 200 and included a "Success"
    # field.  As a result, we have a little bit of custom logic here to raise
    # errors when that field is +false+.
    def check_response(response)
      result = Hash.from_xml(response[:body])
      message = result['TapjoyConnectReturnObject']

      if message['Success'] != 'true'
        raise "Request failure: #{message['Message']}"
      end
    end
  end
end
